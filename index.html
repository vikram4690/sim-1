<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Simulator with Improved Robot Design</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    /* Info panel in the top-left */
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
    }
    /* Control panel in the top-right */
    #controlPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
    }
    #controlPanel label, #controlPanel span {
      font-size: 14px;
    }
  </style>
  <!-- Import map to resolve "three" module specifier -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="info">
    <strong>Robot Simulator</strong><br>
    Use the control panel to adjust the robot camera view rotation.
  </div>
  <div id="controlPanel">
    <label for="cameraRotationInput">Camera View Rotation (Â°): </label>
    <input type="range" id="cameraRotationInput" min="-180" max="180" value="0" step="1">
    <span id="cameraRotationValue">0</span>
  </div>
  <div id="hud" style="position:absolute; bottom:10px; left:10px; color:#fff; background:rgba(0,0,0,0.6); padding:10px; border-radius:4px; z-index:1;">
  Collisions: <span id="collisionCount">0</span>
</div>

  <!-- Use module script for Three.js and OrbitControls -->
 
  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js';

  // === SETUP: Scene, Camera, Renderer ===
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 20, 30);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10, 20, 10);
  scene.add(dirLight);

  // === FLOOR & ENV ===
  const floorGeo = new THREE.PlaneGeometry(100, 100);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // Obstacles & helpers
  let obstacles = [];
  const obstacleGeometry = new THREE.BoxGeometry(4, 4, 4);
  const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

  function addObstacleAt(x, y=2, z=0) {
    const obs = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
    obs.position.set(x, y, z);
    obs.boundingBox = new THREE.Box3().setFromObject(obs);
    scene.add(obs);
    obstacles.push(obs);
    return obs;
  }

  let collisionCount = 0;
  const collisionCountEl = document.getElementById('collisionCount');
  function updateCollisionHUD() { collisionCountEl.textContent = String(collisionCount); }
  updateCollisionHUD();


  // Initial obstacles
  const obstaclePositions = [
    { x: 10, y: 2, z: 0 }, { x: -10, y: 2, z: -10 }, { x: 0, y: 2, z: 10 },
    { x: 15, y: 2, z: 5 }, { x: -12, y: 2, z: 12 }, { x: 5, y: 2, z: -15 },
    { x: -8, y: 2, z: -5 }, { x: 20, y: 2, z: 20 }, { x: -18, y: 2, z: -3 },
    { x: 13, y: 2, z: -7 }, { x: -7, y: 2, z: 8 }, { x: 18, y: 2, z: -10 },
    { x: -5, y: 2, z: 17 }, { x: 12, y: 2, z: 13 }, { x: -16, y: 2, z: -14 },
    { x: 3, y: 2, z: -12 }, { x: -14, y: 2, z: 0 }, { x: 7, y: 2, z: 16 },
    { x: -20, y: 2, z: 10 }, { x: 0, y: 2, z: -20 }, { x: 4, y: 2, z: 4 }
  ];
  obstaclePositions.forEach(p => addObstacleAt(p.x, p.y, p.z));

  // === ROBOT ===
  const robot = new THREE.Group();

  const bodyGeometry = new THREE.BoxGeometry(2, 3, 1);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.4 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.set(0, 1.5, 0);
  robot.add(body);

  const headGeometry = new THREE.SphereGeometry(0.75, 32, 32);
  const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffcccc, metalness: 0.3, roughness: 0.5 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.set(0, 3.25, 0);
  robot.add(head);

  const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 16);
  const armMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.4 });
  const leftArm = new THREE.Mesh(armGeometry, armMaterial);
  leftArm.rotation.z = Math.PI / 2; leftArm.position.set(-1.3, 2, 0); robot.add(leftArm);
  const rightArm = new THREE.Mesh(armGeometry, armMaterial);
  rightArm.rotation.z = Math.PI / 2; rightArm.position.set(1.3, 2, 0); robot.add(rightArm);

  const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 16);
  const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.2, roughness: 0.7 });
  const leftLeg = new THREE.Mesh(legGeometry, legMaterial); leftLeg.position.set(-0.5, 0.75, 0); robot.add(leftLeg);
  const rightLeg = new THREE.Mesh(legGeometry, legMaterial); rightLeg.position.set(0.5, 0.75, 0); robot.add(rightLeg);

  robot.position.set(0, 0, 0);
  scene.add(robot);
  let robotBox = new THREE.Box3().setFromObject(robot);

  // Robot camera attached to head
  const robotCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  robotCamera.position.set(0, 0.5, 0);
  head.add(robotCamera);

  // === GOAL POST ===
  let goalMesh = null;
  let goalBox = null;
  function setGoalAt(pos) {
    if (!goalMesh) {
      const pole = new THREE.CylinderGeometry(0.2, 0.2, 3, 16);
      const poleMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const flag = new THREE.BoxGeometry(1.5, 0.8, 0.05);
      const flagMat = new THREE.MeshStandardMaterial({ color: 0x00ccff });

      const goalGroup = new THREE.Group();
      const poleMesh = new THREE.Mesh(pole, poleMat);
      poleMesh.position.set(0, 1.5, 0);
      const flagMesh = new THREE.Mesh(flag, flagMat);
      flagMesh.position.set(0.9, 2.2, 0);
      goalGroup.add(poleMesh); goalGroup.add(flagMesh);

      goalMesh = goalGroup;
      scene.add(goalMesh);
      goalBox = new THREE.Box3().setFromObject(goalMesh);
    }
    goalMesh.position.set(pos.x, pos.y ?? 0, pos.z);
    goalBox.setFromObject(goalMesh);
  }

  // === WEBSOCKET ===
  const ws = new WebSocket("ws://localhost:8080");
  ws.onopen = () => {
    console.log("WebSocket connected");
    ws.send(JSON.stringify({ type: "connection", message: "Robot simulator connected." }));
  };
  ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    console.log("Received message:", msg);

    // Absolute Movement
    if (msg.command === "move" && msg.target) {
      targetPos = new THREE.Vector3(msg.target.x, msg.target.y ?? 0, msg.target.z);
      moving = true;
      robot.userData.relative = false;
      ws.send(JSON.stringify({ type: "confirmation", message: "Move command received", target: msg.target }));
    }
    // Relative Movement
    else if (msg.command === "move_relative" && (msg.turn !== undefined) && (msg.distance !== undefined)) {
      const angleRad = msg.turn * (Math.PI / 180);
      robot.rotation.y += angleRad;
      targetPos = robot.position.clone().add(
        new THREE.Vector3(Math.sin(robot.rotation.y), 0, Math.cos(robot.rotation.y))
          .multiplyScalar(msg.distance)
      );
      moving = true;
      robot.userData.relative = true;
      ws.send(JSON.stringify({ type: "confirmation", message: "Relative move command executed", target: { angle: msg.turn, distance: msg.distance } }));
    }
    // Stop
    else if (msg.command === "stop") {
      moving = false; targetPos = null;
      ws.send(JSON.stringify({ type: "confirmation", message: "Stop command executed" }));
    }
    // Capture image
    else if (msg.command === "capture_image") {
      captureImage();
    }
    // NEW: Set Goal
    else if (msg.command === "set_goal" && msg.position) {
      setGoalAt(msg.position);
      ws.send(JSON.stringify({ type: "confirmation", message: "Goal set", position: msg.position }));
    }
    // NEW: Replace obstacles
    else if (msg.command === "set_obstacles" && Array.isArray(msg.positions)) {
      // Remove old
      obstacles.forEach(o => scene.remove(o));
      obstacles = [];
      // Add new
      msg.positions.forEach(p => addObstacleAt(p.x, p.y ?? 2, p.z));
      // Reset velocities array to match new obstacles if moving
      if (movingObstacles.enabled) {
        movingObstacles.velocities = buildVelocitiesArray(msg.positions.length, movingObstacles.velocities);
      }
      ws.send(JSON.stringify({ type: "confirmation", message: "Obstacles updated", count: obstacles.length }));
    }
    // NEW: Obstacle motion control
    else if (msg.command === "set_obstacle_motion") {
      movingObstacles.enabled = !!msg.enabled;
      movingObstacles.speed = typeof msg.speed === 'number' ? msg.speed : movingObstacles.speed;
      movingObstacles.bounds = msg.bounds || movingObstacles.bounds;
      movingObstacles.bounce = (msg.bounce !== undefined) ? !!msg.bounce : movingObstacles.bounce;

      // Align velocities array length with obstacles count
      movingObstacles.velocities = buildVelocitiesArray(
        obstacles.length,
        Array.isArray(msg.velocities) ? msg.velocities : null
      );
      ws.send(JSON.stringify({ type: "confirmation", message: "Obstacle motion updated", enabled: movingObstacles.enabled }));
    }

    else if (msg.command === "reset") {
      // stop motion
      moving = false; targetPos = null;

      // reset robot pose & color
      robot.position.set(0, 0, 0);
      robot.rotation.set(0, 0, 0);
      body.material.color.set(0xff0000);

      // reset local counter
      collisionCount = 0;
      updateCollisionHUD();

      // optional: remove goal highlight color if any
      // (no-op if you want to keep goal)
      ws.send(JSON.stringify({ type: "confirmation", message: "Simulator reset" }));
    }

  };
  ws.onerror = (e) => console.error("WebSocket error:", e);
  ws.onclose = () => console.log("WebSocket connection closed");

  // === MOVEMENT vars ===
  let targetPos = null;
  let moving = false;
  const speed = 0.1;

  // === CAPTURE ===
  function captureImage() {
    renderer.render(scene, robotCamera);
    const imageData = renderer.domElement.toDataURL("image/png");
    ws.send(JSON.stringify({
      type: "capture_image_response",
      image: imageData,
      timestamp: Date.now(),
      position: { x: robot.position.x, y: robot.position.y, z: robot.position.z }
    }));
    renderer.render(scene, camera);
  }

  // === UI: Camera rotation ===
  const cameraRotationInput = document.getElementById('cameraRotationInput');
  const cameraRotationValue = document.getElementById('cameraRotationValue');
  cameraRotationInput.addEventListener('input', () => {
    const angle = parseFloat(cameraRotationInput.value);
    cameraRotationValue.textContent = angle;
    robotCamera.rotation.y = angle * (Math.PI / 180);
  });

  // === OBSTACLE MOTION STATE ===
  const clock = new THREE.Clock();
  const movingObstacles = {
    enabled: false,
    speed: 0.05, // scalar multiplier per frame
    bounds: { minX: -45, maxX: 45, minZ: -45, maxZ: 45 },
    bounce: true,
    velocities: [] // array of {x: number, z: number}
  };

  function buildVelocitiesArray(n, provided) {
    const arr = new Array(n);
    for (let i = 0; i < n; i++) {
      if (provided && typeof provided[i] === 'object') {
        const vx = Number(provided[i].x ?? 0);
        const vz = Number(provided[i].z ?? 0);
        arr[i] = { x: vx, z: vz };
      } else {
        // random gentle motion if not provided
        arr[i] = { x: (Math.random() * 2 - 1), z: (Math.random() * 2 - 1) };
      }
    }
    return arr;
  }
  // Initialize velocities to match initial obstacles
  movingObstacles.velocities = buildVelocitiesArray(obstacles.length, null);

  function moveObstacles(delta) {
    if (!movingObstacles.enabled) return;
    const s = movingObstacles.speed;
    const { minX, maxX, minZ, maxZ } = movingObstacles.bounds;
    obstacles.forEach((obs, i) => {
      const v = movingObstacles.velocities[i] || { x: 0, z: 0 };
      obs.position.x += v.x * s;
      obs.position.z += v.z * s;

      // bounce on bounds
      if (movingObstacles.bounce) {
        if (obs.position.x < minX || obs.position.x > maxX) {
          v.x *= -1;
          // clamp inside
          obs.position.x = Math.max(minX, Math.min(maxX, obs.position.x));
        }
        if (obs.position.z < minZ || obs.position.z > maxZ) {
          v.z *= -1;
          obs.position.z = Math.max(minZ, Math.min(maxZ, obs.position.z));
        }
        movingObstacles.velocities[i] = v;
      } else {
        // wrap
        if (obs.position.x < minX) obs.position.x = maxX;
        if (obs.position.x > maxX) obs.position.x = minX;
        if (obs.position.z < minZ) obs.position.z = maxZ;
        if (obs.position.z > maxZ) obs.position.z = minZ;
      }
      // update bounding box
      obs.boundingBox.setFromObject(obs);
    });
  }

  // === ANIMATION LOOP ===
  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    controls.update();

    // Robot movement
    if (moving && targetPos) {
      const direction = new THREE.Vector3().subVectors(targetPos, robot.position);
      const dist = direction.length();
      if (dist > 0.1) {
        direction.normalize();
        robot.position.addScaledVector(direction, speed);
        if (!robot.userData.relative) robot.lookAt(targetPos);
      } else {
        moving = false; targetPos = null;
        ws.send(JSON.stringify({ type: "confirmation", message: "Arrived at target", position: robot.position }));
        robot.userData.relative = false;
      }
    }

    // Update robot bounding box and check collisions
    robotBox.setFromObject(robot);
    for (const obs of obstacles) {
      if (robotBox.intersectsBox(obs.boundingBox)) {
        moving = false; targetPos = null;
        body.material.color.set(0xffff00);

        // bump counter + update HUD
        collisionCount += 1;
        updateCollisionHUD();

        // notify server (already existed, keep it)
        ws.send(JSON.stringify({
          type: "collision",
          collision: true,
          position: { x: robot.position.x, y: robot.position.y, z: robot.position.z },
          obstacle: { position: obs.position }
        }));
        break;
      }
    }

    // Move obstacles (if enabled)
    moveObstacles(delta);

    // Check goal reach
    if (goalMesh && goalBox) {
      goalBox.setFromObject(goalMesh);
      if (robotBox.intersectsBox(goalBox)) {
        ws.send(JSON.stringify({
          type: "goal_reached",
          position: { x: robot.position.x, y: robot.position.y, z: robot.position.z }
        }));
        // visual feedback
        body.material.color.set(0x00ffff);
      }
    }

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>